{
    "summary": "The Curriculum Agent uses LangChain's ChatOpenAI and QA_ChatOpenAI for task-based learning, managing cache and tasks, storing info, calculating progress, generating observations during warm-up phase, and includes inventory usage checks. This AI game agent code handles QA interactions with the user, generates messages, asks questions, utilizes QA LLM for responses, processes question-concept pairs, and runs QA step 2 to answer questions.",
    "details": [
        {
            "comment": "Class \"CurriculumAgent\" initializes LangChain's ChatOpenAI and QA_ChatOpenAI for language generation, with various optional parameters like model name, temperature, timeout, resume, mode etc. These LLMs (Language Generation Models) will be used to handle user queries or requests in the curriculum-based agent.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":0-36",
            "content": "from __future__ import annotations\nimport random\nimport re\nimport voyager.utils as U\nfrom voyager.prompts import load_prompt\nfrom voyager.utils.json_utils import fix_and_parse_json\nfrom langchain.chat_models import ChatOpenAI\nfrom langchain.embeddings.openai import OpenAIEmbeddings\nfrom langchain.schema import HumanMessage, SystemMessage\nfrom langchain.vectorstores import Chroma\nclass CurriculumAgent:\n    def __init__(\n        self,\n        model_name=\"gpt-3.5-turbo\",\n        temperature=0,\n        qa_model_name=\"gpt-3.5-turbo\",\n        qa_temperature=0,\n        request_timout=120,\n        ckpt_dir=\"ckpt\",\n        resume=False,\n        mode=\"auto\",\n        warm_up=None,\n        core_inventory_items: str | None = None,\n    ):\n        self.llm = ChatOpenAI(\n            model_name=model_name,\n            temperature=temperature,\n            request_timeout=request_timout,\n        )\n        self.qa_llm = ChatOpenAI(\n            model_name=qa_model_name,\n            temperature=qa_temperature,\n            request_timeout=request_timout,"
        },
        {
            "comment": "This code initializes a Curriculum Agent. It checks the mode (auto or manual), sets the checkpoint directory, and creates a curriculum/vectordb directory if it does not exist. If resuming from a checkpoint, it loads completed tasks, failed tasks, and QA cache from JSON files. Otherwise, it initializes empty lists for these tasks and an empty dictionary for the QA cache. The code then creates a Chroma vector database named \"qa_cache_questions_vectordb\" using the OpenAI embeddings function and specifies the persist directory as ckpt_dir/curriculum/vectordb. It asserts that the count of items in the collection is equal to the length of the loaded QA cache.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":37-62",
            "content": "        )\n        assert mode in [\n            \"auto\",\n            \"manual\",\n        ], f\"mode {mode} not supported\"\n        self.mode = mode\n        self.ckpt_dir = ckpt_dir\n        U.f_mkdir(f\"{ckpt_dir}/curriculum/vectordb\")\n        if resume:\n            print(f\"\\033[35mLoading Curriculum Agent from {ckpt_dir}/curriculum\\033[0m\")\n            self.completed_tasks = U.load_json(\n                f\"{ckpt_dir}/curriculum/completed_tasks.json\"\n            )\n            self.failed_tasks = U.load_json(f\"{ckpt_dir}/curriculum/failed_tasks.json\")\n            self.qa_cache = U.load_json(f\"{ckpt_dir}/curriculum/qa_cache.json\")\n        else:\n            self.completed_tasks = []\n            self.failed_tasks = []\n            self.qa_cache = {}\n        # vectordb for qa cache\n        self.qa_cache_questions_vectordb = Chroma(\n            collection_name=\"qa_cache_questions_vectordb\",\n            embedding_function=OpenAIEmbeddings(),\n            persist_directory=f\"{ckpt_dir}/curriculum/vectordb\",\n        )\n        assert self.qa_cache_questions_vectordb._collection.count() == len("
        },
        {
            "comment": "This code is initializing the Curriculum Agent's QA cache, ensuring that the question vector database (vectordb) is synced with qa_cache.json. It checks if 'resume=False' was set during agent initialization and allows for the manual deletion of qa cache questions vectordb directory for running from scratch. The code also initializes the warm-up variable, ensuring it exists or setting missing values to default values.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":63-81",
            "content": "            self.qa_cache\n        ), (\n            f\"Curriculum Agent's qa cache question vectordb is not synced with qa_cache.json.\\n\"\n            f\"There are {self.qa_cache_questions_vectordb._collection.count()} questions in vectordb \"\n            f\"but {len(self.qa_cache)} questions in qa_cache.json.\\n\"\n            f\"Did you set resume=False when initializing the agent?\\n\"\n            f\"You may need to manually delete the qa cache question vectordb directory for running from scratch.\\n\"\n        )\n        # if warm up not defined, initialize it as a dict, else, initialize all the missing value as a default value\n        if not warm_up:\n            warm_up = self.default_warmup\n        self.warm_up = {}\n        if \"optional_inventory_items\" in warm_up:\n            assert core_inventory_items is not None\n            self._core_inv_items_regex = re.compile(core_inventory_items)\n            self.warm_up[\"optional_inventory_items\"] = warm_up[\n                \"optional_inventory_items\"\n            ]\n        else:"
        },
        {
            "comment": "Sets default warm-up values for curriculum agent, overrides with provided warm-up dictionary.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":82-117",
            "content": "            self.warm_up[\"optional_inventory_items\"] = 0\n        for key in self.curriculum_observations:\n            self.warm_up[key] = warm_up.get(key, self.default_warmup[key])\n        self.warm_up[\"nearby_blocks\"] = 0\n        self.warm_up[\"inventory\"] = 0\n        self.warm_up[\"completed_tasks\"] = 0\n        self.warm_up[\"failed_tasks\"] = 0\n    @property\n    def default_warmup(self):\n        return {\n            \"context\": 15,\n            \"biome\": 10,\n            \"time\": 15,\n            \"nearby_blocks\": 0,\n            \"other_blocks\": 10,\n            \"nearby_entities\": 5,\n            \"health\": 15,\n            \"hunger\": 15,\n            \"position\": 0,\n            \"equipment\": 0,\n            \"inventory\": 0,\n            \"optional_inventory_items\": 7,\n            \"chests\": 0,\n            \"completed_tasks\": 0,\n            \"failed_tasks\": 0,\n        }\n    @property\n    def curriculum_observations(self):\n        return [\n            \"context\",\n            \"biome\",\n            \"time\",\n            \"nearby_blocks\",\n            \"other_blocks\","
        },
        {
            "comment": "This code defines a class with properties for storing information like nearby entities, health, hunger, position, equipment, inventory, chest observations, completed tasks, and failed tasks. It also has methods to calculate progress, render system messages, and generate observations based on events and chest observations, including biome, time of day, voxels, block records, entities' status, and player's health and hunger levels.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":118-148",
            "content": "            \"nearby_entities\",\n            \"health\",\n            \"hunger\",\n            \"position\",\n            \"equipment\",\n            \"inventory\",\n            \"chests\",\n            \"completed_tasks\",\n            \"failed_tasks\",\n        ]\n    @property\n    def progress(self):\n        return len(self.completed_tasks)\n    def render_system_message(self):\n        system_message = SystemMessage(content=load_prompt(\"curriculum\"))\n        assert isinstance(system_message, SystemMessage)\n        return system_message\n    def render_observation(self, *, events, chest_observation):\n        assert events[-1][0] == \"observe\", \"Last event must be observe\"\n        event = events[-1][1]\n        biome = event[\"status\"][\"biome\"]\n        time_of_day = event[\"status\"][\"timeOfDay\"]\n        voxels = event[\"voxels\"]\n        block_records = event[\"blockRecords\"]\n        entities = event[\"status\"][\"entities\"]\n        health = event[\"status\"][\"health\"]\n        hunger = event[\"status\"][\"food\"]\n        position = event[\"status\"][\"position\"]"
        },
        {
            "comment": "This code block checks the equipment, inventory used, and overall inventory of an event. If there are no dirt, log, grass, sand, or snow blocks in the voxels, it sets the biome as \"underground\". It then identifies other blocks that were not present in the voxels or inventory, lists nearby entities, and lists completed and failed tasks, while handling cases where they might be empty. Finally, it filters out optional inventory items if required.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":149-182",
            "content": "        equipment = event[\"status\"][\"equipment\"]\n        inventory_used = event[\"status\"][\"inventoryUsed\"]\n        inventory = event[\"inventory\"]\n        if not any(\n            \"dirt\" in block\n            or \"log\" in block\n            or \"grass\" in block\n            or \"sand\" in block\n            or \"snow\" in block\n            for block in voxels\n        ):\n            biome = \"underground\"\n        other_blocks = \", \".join(\n            list(\n                set(block_records).difference(set(voxels).union(set(inventory.keys())))\n            )\n        )\n        other_blocks = other_blocks if other_blocks else \"None\"\n        nearby_entities = (\n            \", \".join([k for k, v in sorted(entities.items(), key=lambda x: x[1])])\n            if entities\n            else \"None\"\n        )\n        completed_tasks = (\n            \", \".join(self.completed_tasks) if self.completed_tasks else \"None\"\n        )\n        failed_tasks = \", \".join(self.failed_tasks) if self.failed_tasks else \"None\"\n        # filter out optional inventory items if required"
        },
        {
            "comment": "The code checks if the agent's progress is less than the warm-up optional inventory items. If so, it filters the inventory based on core item regex and prepares an observation dictionary containing various information such as context, biome, time of day, nearby blocks, other blocks, nearby entities, health, hunger, position, equipment, and inventory (filtered). The observation dictionary is formatted with descriptive strings for each field.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":183-201",
            "content": "        if self.progress < self.warm_up[\"optional_inventory_items\"]:\n            inventory = {\n                k: v\n                for k, v in inventory.items()\n                if self._core_inv_items_regex.search(k) is not None\n            }\n        observation = {\n            \"context\": \"\",\n            \"biome\": f\"Biome: {biome}\\n\\n\",\n            \"time\": f\"Time: {time_of_day}\\n\\n\",\n            \"nearby_blocks\": f\"Nearby blocks: {', '.join(voxels) if voxels else 'None'}\\n\\n\",\n            \"other_blocks\": f\"Other blocks that are recently seen: {other_blocks}\\n\\n\",\n            \"nearby_entities\": f\"Nearby entities: {nearby_entities}\\n\\n\",\n            \"health\": f\"Health: {health:.1f}/20\\n\\n\",\n            \"hunger\": f\"Hunger: {hunger:.1f}/20\\n\\n\",\n            \"position\": f\"Position: x={position['x']:.1f}, y={position['y']:.1f}, z={position['z']:.1f}\\n\\n\",\n            \"equipment\": f\"Equipment: {equipment}\\n\\n\",\n            \"inventory\": f\"Inventory ({inventory_used}/36): {inventory if inventory else 'Empty'}\\n\\n\","
        },
        {
            "comment": "This code generates an observation dictionary containing information about completed tasks, failed tasks, and contextual questions with answers. If the progress is past the warm-up phase, it adds up to 5 relevant questions and answers to the observation's \"context\" field.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":202-227",
            "content": "            \"chests\": chest_observation,\n            \"completed_tasks\": f\"Completed tasks so far: {completed_tasks}\\n\\n\",\n            \"failed_tasks\": f\"Failed tasks that are too hard: {failed_tasks}\\n\\n\",\n        }\n        return observation\n    def render_human_message(self, *, events, chest_observation):\n        content = \"\"\n        observation = self.render_observation(\n            events=events, chest_observation=chest_observation\n        )\n        if self.progress >= self.warm_up[\"context\"]:\n            questions, answers = self.run_qa(\n                events=events, chest_observation=chest_observation\n            )\n            i = 1\n            for question, answer in zip(questions, answers):\n                if \"Answer: Unknown\" in answer or \"language model\" in answer:\n                    continue\n                observation[\"context\"] += f\"Question {i}: {question}\\n\"\n                observation[\"context\"] += f\"{answer}\\n\\n\"\n                i += 1\n                if i > 5:\n                    break\n        for key in self.curriculum_observations:"
        },
        {
            "comment": "The code defines a Curriculum Agent that generates human messages based on progress, warm-up keys, and observation data. It also proposes tasks depending on progress mode and inventory status. If the progress is zero and mode is \"auto\", it suggests mining one wood log. When inventory is almost full, it checks chest observation to propose tasks related to available chests.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":228-250",
            "content": "            if self.progress >= self.warm_up[key]:\n                if self.warm_up[key] != 0:\n                    should_include = random.random() < 0.8\n                else:\n                    should_include = True\n                if should_include:\n                    content += observation[key]\n        print(f\"\\033[35m****Curriculum Agent human message****\\n{content}\\033[0m\")\n        return HumanMessage(content=content)\n    def propose_next_task(self, *, events, chest_observation, max_retries=5):\n        if self.progress == 0 and self.mode == \"auto\":\n            task = \"Mine 1 wood log\"\n            context = \"You can mine one of oak, birch, spruce, jungle, acacia, dark oak, or mangrove logs.\"\n            return task, context\n        # hard code task when inventory is almost full\n        inventoryUsed = events[-1][1][\"status\"][\"inventoryUsed\"]\n        if inventoryUsed >= 33:\n            if chest_observation != \"Chests: None\\n\\n\":\n                chests = chest_observation[8:-2].split(\"\\n\")\n                for chest in chests:"
        },
        {
            "comment": "This code checks the content of a chest and, if it's empty or contains unknown items, creates a task to deposit useless items into it. The user should have 20 occupied slots after depositing, and can use `bot.inventoryUsed()` to check inventory usage.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":251-263",
            "content": "                    content = chest.split(\":\")[1]\n                    if content == \" Unknown items inside\" or content == \" Empty\":\n                        position = chest.split(\":\")[0]\n                        task = f\"Deposit useless items into the chest at {position}\"\n                        context = (\n                            f\"Your inventory have {inventoryUsed} occupied slots before depositing. \"\n                            \"After depositing, your inventory should only have 20 occupied slots. \"\n                            \"You should deposit useless items such as andesite, dirt, cobblestone, etc. \"\n                            \"Also, you can deposit low-level tools, \"\n                            \"For example, if you have a stone pickaxe, you can deposit a wooden pickaxe. \"\n                            \"Make sure the list of useless items are in your inventory \"\n                            \"(do not list items already in the chest), \"\n                            \"You can use bot.inventoryUsed() to check how many inventory slots are used.\""
        },
        {
            "comment": "The code checks if a chest is in the inventory or nearby blocks. If it's present, it sets the task as \"Place a chest\" and provides instructions for placing it around the player. If not, it sets the task as \"Craft 1 chest\" and gives instructions on how to craft one using planks of any wood. The code then generates messages and based on the mode (\"auto\" or \"manual\"), returns the next task proposal or manual task respectively. An error is raised for an invalid mode.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":264-289",
            "content": "                        )\n                        return task, context\n            if \"chest\" in events[-1][1][\"inventory\"]:\n                task = \"Place a chest\"\n                context = (\n                    f\"You have a chest in inventory, place it around you. \"\n                    f\"If chests is not None, or nearby blocks contains chest, this task is success.\"\n                )\n            else:\n                task = \"Craft 1 chest\"\n                context = \"Craft 1 chest with 8 planks of any kind of wood.\"\n            return task, context\n        messages = [\n            self.render_system_message(),\n            self.render_human_message(\n                events=events, chest_observation=chest_observation\n            ),\n        ]\n        if self.mode == \"auto\":\n            return self.propose_next_ai_task(messages=messages, max_retries=max_retries)\n        elif self.mode == \"manual\":\n            return self.propose_next_manual_task()\n        else:\n            raise ValueError(f\"Invalid curriculum agent mode: {self.mode}\")"
        },
        {
            "comment": "The code defines a `propose_next_ai_task` method that retrieves the curriculum from AI and parses it to get the next task. If parsing fails, it retries up to max retries or raises an error if max retries is reached. The code also includes a `parse_ai_message` method that extracts the task from the curriculum message.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":291-314",
            "content": "    def propose_next_ai_task(self, *, messages, max_retries=5):\n        if max_retries == 0:\n            raise RuntimeError(\"Max retries reached, failed to propose ai task.\")\n        curriculum = self.llm(messages).content\n        print(f\"\\033[31m****Curriculum Agent ai message****\\n{curriculum}\\033[0m\")\n        try:\n            response = self.parse_ai_message(curriculum)\n            assert \"next_task\" in response\n            context = self.get_task_context(response[\"next_task\"])\n            return response[\"next_task\"], context\n        except Exception as e:\n            print(\n                f\"\\033[35mError parsing curriculum response: {e}. Trying again!\\033[0m\"\n            )\n            return self.propose_next_ai_task(\n                messages=messages,\n                max_retries=max_retries - 1,\n            )\n    def parse_ai_message(self, message):\n        task = \"\"\n        for line in message.split(\"\\n\"):\n            if line.startswith(\"Task:\"):\n                task = line[5:].replace(\".\", \"\").strip()"
        },
        {
            "comment": "The code snippet contains three functions: \"get_next_task\", \"propose_next_manual_task\", and \"update_exploration_progress\". The first function retrieves the next task from a response, while the second one prompts the user to input a task and context. Lastly, the third function updates progress by checking task completion and adding tasks to completed or failed lists.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":315-342",
            "content": "        assert task, \"Task not found in Curriculum Agent response\"\n        return {\"next_task\": task}\n    def propose_next_manual_task(self):\n        confirmed = False\n        task, context = \"\", \"\"\n        while not confirmed:\n            task = input(\"Enter task: \")\n            context = input(\"Enter context: \")\n            print(f\"Task: {task}\\nContext: {context}\")\n            confirmed = input(\"Confirm? (y/n)\").lower() in [\"y\", \"\"]\n        return task, context\n    def update_exploration_progress(self, info):\n        task = info[\"task\"]\n        if task.startswith(\"Deposit useless items into the chest at\"):\n            # No need to record the deposit task\n            return\n        if info[\"success\"]:\n            print(f\"\\033[35mCompleted task {task}.\\033[0m\")\n            self.completed_tasks.append(task)\n        else:\n            print(\n                f\"\\033[35mFailed to complete task {task}. Skipping to next task.\\033[0m\"\n            )\n            self.failed_tasks.append(task)\n        # clean up tasks and dump to disk"
        },
        {
            "comment": "The code snippet is responsible for cleaning up tasks, separating completed and failed ones, storing them in separate lists, and then dumping the updated lists into JSON files. It also contains a function to decompose a task given a set of events and generates a SystemMessage with content loaded from a curriculum_task_decomposition prompt.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":343-371",
            "content": "        self.clean_up_tasks()\n    def clean_up_tasks(self):\n        updated_completed_tasks = []\n        # record repeated failed tasks\n        updated_failed_tasks = self.failed_tasks\n        # dedup but keep order\n        for task in self.completed_tasks:\n            if task not in updated_completed_tasks:\n                updated_completed_tasks.append(task)\n        # remove completed tasks from failed tasks\n        for task in updated_completed_tasks:\n            while task in updated_failed_tasks:\n                updated_failed_tasks.remove(task)\n        self.completed_tasks = updated_completed_tasks\n        self.failed_tasks = updated_failed_tasks\n        # dump to json\n        U.dump_json(\n            self.completed_tasks, f\"{self.ckpt_dir}/curriculum/completed_tasks.json\"\n        )\n        U.dump_json(self.failed_tasks, f\"{self.ckpt_dir}/curriculum/failed_tasks.json\")\n    def decompose_task(self, task, events):\n        messages = [\n            SystemMessage(\n                content=load_prompt(\"curriculum_task_decomposition\"),"
        },
        {
            "comment": "The code is a part of the Curriculum Agent, which decomposes tasks. It constructs messages for LLM and prints information about the final task. The `run_qa` function retrieves new questions from previous ones, checks if the Vectordb collection has any data, and performs a similarity search to find relevant answers with a score below 0.05.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":372-396",
            "content": "            ),\n            self.render_human_message(events=events, chest_observation=\"\"),\n            HumanMessage(content=f\"Final task: {task}\"),\n        ]\n        print(\n            f\"\\033[31m****Curriculum Agent task decomposition****\\nFinal task: {task}\\033[0m\"\n        )\n        response = self.llm(messages).content\n        print(f\"\\033[31m****Curriculum Agent task decomposition****\\n{response}\\033[0m\")\n        return fix_and_parse_json(response)\n    def run_qa(self, *, events, chest_observation):\n        questions_new, _ = self.run_qa_step1_ask_questions(\n            events=events, chest_observation=chest_observation\n        )\n        questions = []\n        answers = []\n        for question in questions_new:\n            if self.qa_cache_questions_vectordb._collection.count() > 0:\n                docs_and_scores = (\n                    self.qa_cache_questions_vectordb.similarity_search_with_score(\n                        question, k=1\n                    )\n                )\n                if docs_and_scores and docs_and_scores[0][1] < 0.05:"
        },
        {
            "comment": "Code snippet:\n- Stores and retrieves question-answer pairs in cache\n- Uses run_qa_step2_answer_questions to generate answers from questions\n- Adds new question to vectordb and persists it\n- Dumps qa_cache into json file at specified location\n- Checks lengths of questions, answers, and questions_new are equal\n- Tool ore in question may prompt GPT to use touch enhancement tool for mining",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":397-417",
            "content": "                    question_cached = docs_and_scores[0][0].page_content\n                    assert question_cached in self.qa_cache\n                    answer_cached = self.qa_cache[question_cached]\n                    questions.append(question_cached)\n                    answers.append(answer_cached)\n                    continue\n            answer = self.run_qa_step2_answer_questions(question=question)\n            assert question not in self.qa_cache\n            self.qa_cache[question] = answer\n            self.qa_cache_questions_vectordb.add_texts(\n                texts=[question],\n            )\n            U.dump_json(self.qa_cache, f\"{self.ckpt_dir}/curriculum/qa_cache.json\")\n            self.qa_cache_questions_vectordb.persist()\n            questions.append(question)\n            answers.append(answer)\n        assert len(questions_new) == len(questions) == len(answers)\n        return questions, answers\n    def get_task_context(self, task):\n        # if include ore in question, gpt will try to use tool with skill touch enhancement to mine"
        },
        {
            "comment": "This code appears to be part of an AI agent that interacts with a user, likely in the context of a game like Minecraft. The code handles questions from the user and answers them using a caching system. It also seems to involve persistence of question-answer pairs for future reference, as well as rendering messages to guide the interaction.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":418-440",
            "content": "        question = (\n            f\"How to {task.replace('_', ' ').replace(' ore', '').replace(' ores', '').replace('.', '').strip().lower()}\"\n            f\" in Minecraft?\"\n        )\n        if question in self.qa_cache:\n            answer = self.qa_cache[question]\n        else:\n            answer = self.run_qa_step2_answer_questions(question=question)\n            self.qa_cache[question] = answer\n            self.qa_cache_questions_vectordb.add_texts(\n                texts=[question],\n            )\n            U.dump_json(self.qa_cache, f\"{self.ckpt_dir}/curriculum/qa_cache.json\")\n            self.qa_cache_questions_vectordb.persist()\n        context = f\"Question: {question}\\n{answer}\"\n        return context\n    def render_system_message_qa_step1_ask_questions(self):\n        return SystemMessage(content=load_prompt(\"curriculum_qa_step1_ask_questions\"))\n    def render_human_message_qa_step1_ask_questions(self, *, events, chest_observation):\n        observation = self.render_observation(\n            events=events, chest_observation=chest_observation"
        },
        {
            "comment": "This code defines two methods: \"render_human_message_qa_step1_ask_questions\" and \"run_qa_step1_ask_questions\". The first method generates a human-readable message from the given events and chest observation. The second method asks three questions related to blocks, items, and mobs in a specific biome in Minecraft using the information from events and chest observation. It then passes these messages to the QA LLM for response, extracts question-concept pairs using regex, and tries to execute it.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":441-464",
            "content": "        )\n        content = \"\"\n        for key in self.curriculum_observations:\n            content += observation[key]\n        return HumanMessage(content=content)\n    def run_qa_step1_ask_questions(self, *, events, chest_observation):\n        biome = events[-1][1][\"status\"][\"biome\"].replace(\"_\", \" \")\n        questions = [\n            f\"What are the blocks that I can find in the {biome} in Minecraft?\",\n            f\"What are the items that I can find in the {biome} in Minecraft?\",\n            f\"What are the mobs that I can find in the {biome} in Minecraft?\",\n        ]\n        concepts = [biome, biome, biome]\n        messages = [\n            self.render_system_message_qa_step1_ask_questions(),\n            self.render_human_message_qa_step1_ask_questions(\n                events=events, chest_observation=chest_observation\n            ),\n        ]\n        qa_response = self.qa_llm(messages).content\n        try:\n            # Regex pattern to extract question and concept pairs\n            pattern = r\"Question \\d+: (.+)\\nConcept \\d+: (.+)\""
        },
        {
            "comment": "The code extracts question and concept pairs from the text, stores them in separate lists, checks their lengths are equal, extends existing question and concept lists, handles exceptions while parsing curriculum response, renders system message with prompt for QA step 2, creates a human message with the question, and runs QA step 2 to answer questions.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":465-489",
            "content": "            # Extracting all question and concept pairs from the text\n            pairs = re.findall(pattern, qa_response)\n            # Storing each question and concept in separate lists\n            questions_new = [pair[0] for pair in pairs]\n            concepts_new = [pair[1] for pair in pairs]\n            assert len(questions_new) == len(concepts_new)\n            questions.extend(questions_new)\n            concepts.extend(concepts_new)\n        except Exception as e:\n            print(\n                f\"\\033[35mError parsing curriculum response for \"\n                f\"QA step 1 ask questions: {e}.\\033[0m\"\n            )\n        return questions, concepts\n    def render_system_message_qa_step2_answer_questions(self):\n        return SystemMessage(\n            content=load_prompt(\"curriculum_qa_step2_answer_questions\")\n        )\n    def render_human_message_qa_step2_answer_questions(self, question):\n        content = f\"Question: {question}\"\n        return HumanMessage(content=content)\n    def run_qa_step2_answer_questions(self, question):"
        },
        {
            "comment": "This code renders system and human messages for a QA step, prints the curriculum agent's question, asks the QA language model for an answer, and returns it. The question and answer are printed in different colors for clarity.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/curriculum.py\":490-497",
            "content": "        messages = [\n            self.render_system_message_qa_step2_answer_questions(),\n            self.render_human_message_qa_step2_answer_questions(question=question),\n        ]\n        print(f\"\\033[35mCurriculum Agent Question: {question}\\033[0m\")\n        qa_answer = self.qa_llm(messages).content\n        print(f\"\\033[31mCurriculum Agent {qa_answer}\\033[0m\")\n        return qa_answer"
        }
    ]
}