{
    "summary": "This code offers utility functions for file system operations, including path manipulation and directory traversal, file/directory handling (f_remove, f_copy), wildcard support, error handling, verbose option, file paths & directories management, checksums, tarball creation with compression, utility file handling, NFS-safe lock implementation, and options to load/dump text or pickle data by lines.",
    "details": [
        {
            "comment": "This code file contains various utility functions for working with the file system, such as getting hostname and host ID, opening files in UTF-8 format, checking if an object is a sequence, and packing variable arguments into a list. These functions can be used across different modules within the project for file operations.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/file_utils.py\":0-64",
            "content": "\"\"\"\nFile system utils.\n\"\"\"\nimport collections\nimport os\nimport pickle\nimport sys\nimport errno\nimport shutil\nimport glob\n# import pwd\nimport codecs\nimport hashlib\nimport tarfile\nimport fnmatch\nimport tempfile\nfrom datetime import datetime\nfrom socket import gethostname\nimport logging\nf_ext = os.path.splitext\nf_size = os.path.getsize\nis_file = os.path.isfile\nis_dir = os.path.isdir\nget_dir = os.path.dirname\ndef host_name():\n    \"Get host name, alias with ``socket.gethostname()``\"\n    return gethostname()\ndef host_id():\n    \"\"\"\n    Returns: first part of hostname up to '.'\n    \"\"\"\n    return host_name().split(\".\")[0]\ndef utf_open(fname, mode):\n    \"\"\"\n    Wrapper for codecs.open\n    \"\"\"\n    return codecs.open(fname, mode=mode, encoding=\"utf-8\")\ndef is_sequence(obj):\n    \"\"\"\n    Returns:\n      True if the sequence is a collections.Sequence and not a string.\n    \"\"\"\n    return isinstance(obj, collections.abc.Sequence) and not isinstance(obj, str)\ndef pack_varargs(args):\n    \"\"\"\n    Pack *args or a single list arg as list\n    def f(*args):"
        },
        {
            "comment": "The code defines a series of utility functions for file manipulation. It includes functions like `f_not_empty` which checks if the given file exists and has a non-zero size, `f_expand` to expand special symbols in file paths, `f_exists` to check if a file path exists, and `f_join` to join file paths while expanding special symbols. The code also uses `pack_varargs` for packing arguments into a list format.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/file_utils.py\":65-106",
            "content": "        arg_list = pack_varargs(args)\n        # arg_list is now packed as a list\n    \"\"\"\n    assert isinstance(args, tuple), \"please input the tuple `args` as in *args\"\n    if len(args) == 1 and is_sequence(args[0]):\n        return args[0]\n    else:\n        return args\ndef f_not_empty(*fpaths):\n    \"\"\"\n    Returns:\n        True if and only if the file exists and file size > 0\n          if fpath is a dir, if and only if dir exists and has at least 1 file\n    \"\"\"\n    fpath = f_join(*fpaths)\n    if not os.path.exists(fpath):\n        return False\n    if os.path.isdir(fpath):\n        return len(os.listdir(fpath)) > 0\n    else:\n        return os.path.getsize(fpath) > 0\ndef f_expand(fpath):\n    return os.path.expandvars(os.path.expanduser(fpath))\ndef f_exists(*fpaths):\n    return os.path.exists(f_join(*fpaths))\ndef f_join(*fpaths):\n    \"\"\"\n    join file paths and expand special symbols like `~` for home dir\n    \"\"\"\n    fpaths = pack_varargs(fpaths)\n    fpath = f_expand(os.path.join(*fpaths))\n    if isinstance(fpath, str):\n        fpath = fpath.strip()"
        },
        {
            "comment": "This function, f_listdir, takes in one or more file paths as arguments and returns a list of files in the specified directories. It can filter files based on their extension or through a user-defined function, sort the file names alphabetically, return full paths to the dir contents, handle non-existent directories gracefully, and optionally use os.walk for recursive directory traversal. However, filter_ext and filter cannot be used together.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/file_utils.py\":107-135",
            "content": "    return fpath\ndef f_listdir(\n    *fpaths,\n    filter_ext=None,\n    filter=None,\n    sort=True,\n    full_path=False,\n    nonexist_ok=True,\n    recursive=False,\n):\n    \"\"\"\n    Args:\n        full_path: True to return full paths to the dir contents\n        filter: function that takes in file name and returns True to include\n        nonexist_ok: True to return [] if the dir is non-existent, False to raise\n        sort: sort the file names by alphabetical\n        recursive: True to use os.walk to recursively list files. Note that `filter`\n            will be applied to the relative path string to the root dir.\n            e.g. filter will take \"a/data1.txt\" and \"a/b/data3.txt\" as input, instead of\n            just the base file names \"data1.txt\" and \"data3.txt\".\n            if False, will simply call os.listdir()\n    \"\"\"\n    assert not (filter_ext and filter), \"filter_ext and filter are mutually exclusive\"\n    dir_path = f_join(*fpaths)\n    if not os.path.exists(dir_path) and nonexist_ok:\n        return []\n    if recursive:"
        },
        {
            "comment": "The code defines three functions: \"f_list\", \"f_mkdir\", and \"last_part_in_path\". \n\"f_list\" takes a root directory and optional filter or sort parameters, and returns a list of files in the directory. It can also return absolute paths if the 'full_path' parameter is set to True. \n\"f_mkdir\" recursively creates all subdirectories leading up to a specified file path, creating them only if they do not already exist. \n\"last_part_in_path\" returns the last part of a given file path by splitting it using '/'.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/file_utils.py\":136-176",
            "content": "        files = [\n            os.path.join(os.path.relpath(root, dir_path), file)\n            for root, _, files in os.walk(dir_path)\n            for file in files\n        ]\n    else:\n        files = os.listdir(dir_path)\n    if filter is not None:\n        files = [f for f in files if filter(f)]\n    elif filter_ext is not None:\n        files = [f for f in files if f.endswith(filter_ext)]\n    if sort:\n        files.sort()\n    if full_path:\n        return [os.path.join(dir_path, f) for f in files]\n    else:\n        return files\ndef f_mkdir(*fpaths):\n    \"\"\"\n    Recursively creates all the subdirs\n    If exist, do nothing.\n    \"\"\"\n    fpath = f_join(*fpaths)\n    os.makedirs(fpath, exist_ok=True)\n    return fpath\ndef f_mkdir_in_path(*fpaths):\n    \"\"\"\n    fpath is a file,\n    recursively creates all the parent dirs that lead to the file\n    If exist, do nothing.\n    \"\"\"\n    os.makedirs(get_dir(f_join(*fpaths)), exist_ok=True)\ndef last_part_in_path(fpath):\n    \"\"\"\n    https://stackoverflow.com/questions/3925096/how-to-get-only-the-last-part-of-a-path-in-python"
        },
        {
            "comment": "The code defines various file utility functions. It checks if a path is absolute or relative, retrieves file modification time, appends suffix to file name retaining its extension, adds an extension if not already present, tests if the file has a specific extension, and globally searches for files recursively.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/file_utils.py\":177-226",
            "content": "    \"\"\"\n    return os.path.basename(os.path.normpath(f_expand(fpath)))\ndef is_abs_path(*fpath):\n    return os.path.isabs(f_join(*fpath))\ndef is_relative_path(*fpath):\n    return not is_abs_path(f_join(*fpath))\ndef f_time(*fpath):\n    \"File modification time\"\n    return str(os.path.getctime(f_join(*fpath)))\ndef f_append_before_ext(fpath, suffix):\n    \"\"\"\n    Append a suffix to file name and retain its extension\n    \"\"\"\n    name, ext = f_ext(fpath)\n    return name + suffix + ext\ndef f_add_ext(fpath, ext):\n    \"\"\"\n    Append an extension if not already there\n    Args:\n      ext: will add a preceding `.` if doesn't exist\n    \"\"\"\n    if not ext.startswith(\".\"):\n        ext = \".\" + ext\n    if fpath.endswith(ext):\n        return fpath\n    else:\n        return fpath + ext\ndef f_has_ext(fpath, ext):\n    \"Test if file path is a text file\"\n    _, actual_ext = f_ext(fpath)\n    return actual_ext == \".\" + ext.lstrip(\".\")\ndef f_glob(*fpath):\n    return glob.glob(f_join(*fpath), recursive=True)\ndef f_remove(*fpath, verbose=False, dry_run=False):"
        },
        {
            "comment": "The code defines two functions: `f_remove` and `f_copy`. `f_remove` removes a file or directory specified by the given path, supporting wildcards. It prints a dry-run message if in that mode, and handles different OSError scenarios to remove either directories or files. `f_copy` copies files or directories from one location to another, supporting wildcards and ignoring/including certain files as specified by `ignore` and `include`. If any OSError occurs while copying a directory, it attempts to copy the file instead. If verbose is True, it prints success messages for each deletion or copy action.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/file_utils.py\":227-261",
            "content": "    \"\"\"\n    If exist, remove. Supports both dir and file. Supports glob wildcard.\n    \"\"\"\n    assert isinstance(verbose, bool)\n    fpath = f_join(fpath)\n    if dry_run:\n        print(\"Dry run, delete:\", fpath)\n        return\n    for f in glob.glob(fpath):\n        try:\n            shutil.rmtree(f)\n        except OSError as e:\n            if e.errno == errno.ENOTDIR:\n                try:\n                    os.remove(f)\n                except:  # final resort safeguard\n                    pass\n    if verbose:\n        print(f'Deleted \"{fpath}\"')\ndef f_copy(fsrc, fdst, ignore=None, include=None, exists_ok=True, verbose=False):\n    \"\"\"\n    Supports both dir and file. Supports glob wildcard.\n    \"\"\"\n    fsrc, fdst = f_expand(fsrc), f_expand(fdst)\n    for f in glob.glob(fsrc):\n        try:\n            f_copytree(f, fdst, ignore=ignore, include=include, exist_ok=exists_ok)\n        except OSError as e:\n            if e.errno == errno.ENOTDIR:\n                shutil.copy(f, fdst)\n            else:\n                raise\n    if verbose:"
        },
        {
            "comment": "This code defines a function called `_f_copytree` that copies files and directories from one location to another, allowing for existing destination files and directories if the `exist_ok` parameter is set to True. It also includes functionality to handle symbolic links, ignoring certain names specified by an optional `ignore` function, and using the `os`, `shutil`, and `path` modules.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/file_utils.py\":262-298",
            "content": "        print(f'Copied \"{fsrc}\" to \"{fdst}\"')\ndef _f_copytree(\n    src,\n    dst,\n    symlinks=False,\n    ignore=None,\n    exist_ok=True,\n    copy_function=shutil.copy2,\n    ignore_dangling_symlinks=False,\n):\n    \"\"\"Copied from python standard lib shutil.copytree\n    except that we allow exist_ok\n    Use f_copytree as entry\n    \"\"\"\n    names = os.listdir(src)\n    if ignore is not None:\n        ignored_names = ignore(src, names)\n    else:\n        ignored_names = set()\n    os.makedirs(dst, exist_ok=exist_ok)\n    errors = []\n    for name in names:\n        if name in ignored_names:\n            continue\n        srcname = os.path.join(src, name)\n        dstname = os.path.join(dst, name)\n        try:\n            if os.path.islink(srcname):\n                linkto = os.readlink(srcname)\n                if symlinks:\n                    # We can't just leave it to `copy_function` because legacy\n                    # code with a custom `copy_function` may rely on copytree\n                    # doing the right thing.\n                    os.symlink(linkto, dstname)"
        },
        {
            "comment": "This code handles copying files and directories between two locations. If symlinks are ignored, it uses shutil.copystat to preserve file permissions. If a dangling symlink is encountered and ignore_dangling_symlinks flag is on, the code continues to the next file or directory. It uses _f_copytree for copying directories recursively and calls copy_function for files. Errors are caught and handled to continue with other files.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/file_utils.py\":299-318",
            "content": "                    shutil.copystat(srcname, dstname, follow_symlinks=not symlinks)\n                else:\n                    # ignore dangling symlink if the flag is on\n                    if not os.path.exists(linkto) and ignore_dangling_symlinks:\n                        continue\n                    # otherwise let the copy occurs. copy2 will raise an error\n                    if os.path.isdir(srcname):\n                        _f_copytree(\n                            srcname, dstname, symlinks, ignore, exist_ok, copy_function\n                        )\n                    else:\n                        copy_function(srcname, dstname)\n            elif os.path.isdir(srcname):\n                _f_copytree(srcname, dstname, symlinks, ignore, exist_ok, copy_function)\n            else:\n                # Will raise a SpecialFileError for unsupported file types\n                copy_function(srcname, dstname)\n        # catch the Error from the recursive copytree so that we can\n        # continue with other files\n        except shutil.Error as err:"
        },
        {
            "comment": "The code defines a function _include_patterns that creates and returns a function _ignore_patterns to be used with shutil.copytree(). It takes glob-style patterns as arguments, and determines what files to NOT ignore in the file hierarchy rooted at the source directory when copying using shutil.copystat(). Errors during file operations are handled by raising an Error if any occur.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/file_utils.py\":319-349",
            "content": "            errors.extend(err.args[0])\n        except OSError as why:\n            errors.append((srcname, dstname, str(why)))\n    try:\n        shutil.copystat(src, dst)\n    except OSError as why:\n        # Copying file access times may fail on Windows\n        if getattr(why, \"winerror\", None) is None:\n            errors.append((src, dst, str(why)))\n    if errors:\n        raise shutil.Error(errors)\n    return dst\ndef _include_patterns(*patterns):\n    \"\"\"Factory function that can be used with copytree() ignore parameter.\n    Arguments define a sequence of glob-style patterns\n    that are used to specify what files to NOT ignore.\n    Creates and returns a function that determines this for each directory\n    in the file hierarchy rooted at the source directory when used with\n    shutil.copytree().\n    \"\"\"\n    def _ignore_patterns(path, names):\n        keep = set(\n            name for pattern in patterns for name in fnmatch.filter(names, pattern)\n        )\n        ignore = set(\n            name\n            for name in names"
        },
        {
            "comment": "This code includes functions for copying, moving and splitting file paths. The `f_copytree` function copies a source directory to a destination, ignoring certain patterns. The `f_move` function moves files from one location to another. Lastly, the `f_split_path` function splits a file path into a list of its component folders.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/file_utils.py\":350-386",
            "content": "            if name not in keep and not os.path.isdir(os.path.join(path, name))\n        )\n        return ignore\n    return _ignore_patterns\ndef f_copytree(fsrc, fdst, symlinks=False, ignore=None, include=None, exist_ok=True):\n    fsrc, fdst = f_expand(fsrc), f_expand(fdst)\n    assert (ignore is None) or (\n        include is None\n    ), \"ignore= and include= are mutually exclusive\"\n    if ignore:\n        ignore = shutil.ignore_patterns(*ignore)\n    elif include:\n        ignore = _include_patterns(*include)\n    _f_copytree(fsrc, fdst, ignore=ignore, symlinks=symlinks, exist_ok=exist_ok)\ndef f_move(fsrc, fdst):\n    fsrc, fdst = f_expand(fsrc), f_expand(fdst)\n    for f in glob.glob(fsrc):\n        shutil.move(f, fdst)\ndef f_split_path(fpath, normpath=True):\n    \"\"\"\n    Splits path into a list of its component folders\n    Args:\n        normpath: call os.path.normpath to remove redundant '/' and\n            up-level references like \"..\"\n    \"\"\"\n    if normpath:\n        fpath = os.path.normpath(fpath)\n    allparts = []\n    while 1:"
        },
        {
            "comment": "This code defines several functions to deal with file paths and directories. The `get_allparts()` function splits a file path into its directory and base name, handling both absolute and relative paths. The `get_script_dir()`, `get_script_file_name()`, and `get_script_self_path()` functions return the directory, filename, and absolute path of the current script, respectively. Lastly, the `get_parent_dir()` function takes a location (directory or file) and returns its parent directory's path, either relative or absolute depending on the optional argument.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/file_utils.py\":387-430",
            "content": "        parts = os.path.split(fpath)\n        if parts[0] == fpath:  # sentinel for absolute paths\n            allparts.insert(0, parts[0])\n            break\n        elif parts[1] == fpath:  # sentinel for relative paths\n            allparts.insert(0, parts[1])\n            break\n        else:\n            fpath = parts[0]\n            allparts.insert(0, parts[1])\n    return allparts\ndef get_script_dir():\n    \"\"\"\n    Returns: the dir of current script\n    \"\"\"\n    return os.path.dirname(os.path.realpath(sys.argv[0]))\ndef get_script_file_name():\n    \"\"\"\n    Returns: the dir of current script\n    \"\"\"\n    return os.path.basename(sys.argv[0])\ndef get_script_self_path():\n    \"\"\"\n    Returns: the dir of current script\n    \"\"\"\n    return os.path.realpath(sys.argv[0])\ndef get_parent_dir(location, abspath=False):\n    \"\"\"\n    Args:\n      location: current directory or file\n    Returns:\n        parent directory absolute or relative path\n    \"\"\"\n    _path = os.path.abspath if abspath else os.path.relpath\n    return _path(f_join(location, os.pardir))"
        },
        {
            "comment": "The code provides functions for calculating an MD5 checksum of a file and creating a tarball. The `md5_checksum` function takes a file path as input and returns the MD5 hash of its contents in hexdigest format. The `create_tar` function creates a tarball from either a source file or folder, optionally compressing it with gzip, bzip2, or xz, and allows for including or excluding specific files based on patterns. If any include or ignore patterns are provided, the source files are temporarily copied to a new directory before being compressed into the tarball.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/file_utils.py\":433-462",
            "content": "def md5_checksum(*fpath):\n    \"\"\"\n    File md5 signature\n    \"\"\"\n    hash_md5 = hashlib.md5()\n    with open(f_join(*fpath), \"rb\") as f:\n        for chunk in iter(lambda: f.read(65536), b\"\"):\n            hash_md5.update(chunk)\n    return hash_md5.hexdigest()\ndef create_tar(fsrc, output_tarball, include=None, ignore=None, compress_mode=\"gz\"):\n    \"\"\"\n    Args:\n        fsrc: source file or folder\n        output_tarball: output tar file name\n        compress_mode: \"gz\", \"bz2\", \"xz\" or \"\" (empty for uncompressed write)\n        include: include pattern, will trigger copy to temp directory\n        ignore: ignore pattern, will trigger copy to temp directory\n    \"\"\"\n    fsrc, output_tarball = f_expand(fsrc), f_expand(output_tarball)\n    assert compress_mode in [\"gz\", \"bz2\", \"xz\", \"\"]\n    src_base = os.path.basename(fsrc)\n    tempdir = None\n    if include or ignore:\n        tempdir = tempfile.mkdtemp()\n        tempdest = f_join(tempdir, src_base)\n        f_copy(fsrc, tempdest, include=include, ignore=ignore)\n        fsrc = tempdest"
        },
        {
            "comment": "Code snippet is from Voyager project and contains three functions: 'create_tar', 'extract_tar' and 'move_with_backup'.\n\n1. 'create_tar' creates a tar archive with the option to specify compression mode, source path, and the base name for the archive. It also removes the temporary directory if it exists.\n2. 'extract_tar' extracts members from the specified tar archive into a destination directory, allowing specification of members to extract.\n3. 'move_with_backup' ensures that a file or path is not occupied by renaming existing files with a suffix and recursively backs up everything in the directory.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/file_utils.py\":464-495",
            "content": "    with tarfile.open(output_tarball, \"w:\" + compress_mode) as tar:\n        tar.add(fsrc, arcname=src_base)\n    if tempdir:\n        f_remove(tempdir)\ndef extract_tar(source_tarball, output_dir=\".\", members=None):\n    \"\"\"\n    Args:\n        source_tarball: extract members from archive\n        output_dir: default to current working dir\n        members: must be a subset of the list returned by getmembers()\n    \"\"\"\n    source_tarball, output_dir = f_expand(source_tarball), f_expand(output_dir)\n    with tarfile.open(source_tarball, \"r:*\") as tar:\n        tar.extractall(output_dir, members=members)\ndef move_with_backup(*fpath, suffix=\".bak\"):\n    \"\"\"\n    Ensures that a path is not occupied. If there is a file, rename it by\n    adding @suffix. Resursively backs up everything.\n    Args:\n        fpath: file path to clear\n        suffix: Add to backed up files (default: {'.bak'})\n    \"\"\"\n    fpath = str(f_join(*fpath))\n    if os.path.exists(fpath):\n        move_with_backup(fpath + suffix)\n        shutil.move(fpath, fpath + suffix)"
        },
        {
            "comment": "This code contains several utility functions for file operations, including inserting a string before the extension of a file name, generating timestamp-based file names, implementing a NFS-safe file lock using flufl.lock, loading and dumping pickles, and loading text files. The code also includes some logging setup for the flufl.lock module.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/file_utils.py\":498-537",
            "content": "def insert_before_ext(name, insert):\n    \"\"\"\n    log.txt -> log.ep50.txt\n    \"\"\"\n    name, ext = os.path.splitext(name)\n    return name + insert + ext\ndef timestamp_file_name(fname):\n    timestr = datetime.now().strftime(\"_%H-%M-%S_%m-%d-%y\")\n    return insert_before_ext(fname, timestr)\ndef get_file_lock(*fpath, timeout: int = 15, logging_level=\"critical\"):\n    \"\"\"\n    NFS-safe filesystem-backed lock. `pip install flufl.lock`\n    https://flufllock.readthedocs.io/en/stable/apiref.html\n    Args:\n        fpath: should be a path on NFS so that every process can see it\n        timeout: seconds\n    \"\"\"\n    from flufl.lock import Lock\n    logging.getLogger(\"flufl.lock\").setLevel(logging_level.upper())\n    return Lock(f_join(*fpath), lifetime=timeout)\ndef load_pickle(*fpaths):\n    with open(f_join(*fpaths), \"rb\") as fp:\n        return pickle.load(fp)\ndef dump_pickle(data, *fpaths):\n    with open(f_join(*fpaths), \"wb\") as fp:\n        pickle.dump(data, fp)\ndef load_text(*fpaths, by_lines=False):\n    with open(f_join(*fpaths), \"r\") as fp:"
        },
        {
            "comment": "The code defines various functions for loading and dumping text or pickle data, providing options to read by lines or not. It also includes alias names to maintain consistency with other load_* and dump_* functions in the codebase.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/file_utils.py\":538-567",
            "content": "        if by_lines:\n            return fp.readlines()\n        else:\n            return fp.read()\ndef load_text_lines(*fpaths):\n    return load_text(*fpaths, by_lines=True)\ndef dump_text(s, *fpaths):\n    with open(f_join(*fpaths), \"w\") as fp:\n        fp.write(s)\ndef dump_text_lines(lines: list[str], *fpaths, add_newline=True):\n    with open(f_join(*fpaths), \"w\") as fp:\n        for line in lines:\n            print(line, file=fp, end=\"\\n\" if add_newline else \"\")\n# aliases to be consistent with other load_* and dump_*\npickle_load = load_pickle\npickle_dump = dump_pickle\ntext_load = load_text\nread_text = load_text\nread_text_lines = load_text_lines\nwrite_text = dump_text\nwrite_text_lines = dump_text_lines\ntext_dump = dump_text"
        }
    ]
}