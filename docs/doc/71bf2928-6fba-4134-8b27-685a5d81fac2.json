{
    "summary": "The `exploreUntil` function executes exploration tasks with a maximum time limit, resolving the result or null based on success or timeout.",
    "details": [
        {
            "comment": "Explore downward for 60 seconds: exploreUntil(bot, new Vec3(0, -1, 0), 60);\n\nThe function `exploreUntil` takes a bot, direction, maximum time (default 60), and a callback. It checks if maxTime is a number, and if the callback is a function. If successful, it returns a resolved promise with the test result. If direction is 0 in all dimensions, it throws an error. If direction values are not -1, 0, or 1, it also throws an error.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/control_primitives/exploreUntil.js\":0-32",
            "content": "// Explore downward for 60 seconds: exploreUntil(bot, new Vec3(0, -1, 0), 60);\nasync function exploreUntil(\n    bot,\n    direction,\n    maxTime = 60,\n    callback = () => {\n        return false;\n    }\n) {\n    if (typeof maxTime !== \"number\") {\n        throw new Error(\"maxTime must be a number\");\n    }\n    if (typeof callback !== \"function\") {\n        throw new Error(\"callback must be a function\");\n    }\n    const test = callback();\n    if (test) {\n        bot.chat(\"Explore success.\");\n        return Promise.resolve(test);\n    }\n    if (direction.x === 0 && direction.y === 0 && direction.z === 0) {\n        throw new Error(\"direction cannot be 0, 0, 0\");\n    }\n    if (\n        !(\n            (direction.x === 0 || direction.x === 1 || direction.x === -1) &&\n            (direction.y === 0 || direction.y === 1 || direction.y === -1) &&\n            (direction.z === 0 || direction.z === 1 || direction.z === -1)\n        )\n    ) {\n        throw new Error(\n            \"direction must be a Vec3 only with value of -1, 0 or 1\"\n        );"
        },
        {
            "comment": "The code sets up an interval-based exploration function that randomly generates new exploration goals within a 20x20x20 block around the current entity position. The maxTime parameter limits the total time spent exploring to either the specified value or 1200 seconds. The function returns a Promise, and includes cleanup functions for clearing the interval and goal when complete or timed out.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/control_primitives/exploreUntil.js\":33-66",
            "content": "    }\n    maxTime = Math.min(maxTime, 1200);\n    return new Promise((resolve, reject) => {\n        const dx = direction.x;\n        const dy = direction.y;\n        const dz = direction.z;\n        let explorationInterval;\n        let maxTimeTimeout;\n        const cleanUp = () => {\n            clearInterval(explorationInterval);\n            clearTimeout(maxTimeTimeout);\n            bot.pathfinder.setGoal(null);\n        };\n        const explore = () => {\n            const x =\n                bot.entity.position.x +\n                Math.floor(Math.random() * 20 + 10) * dx;\n            const y =\n                bot.entity.position.y +\n                Math.floor(Math.random() * 20 + 10) * dy;\n            const z =\n                bot.entity.position.z +\n                Math.floor(Math.random() * 20 + 10) * dz;\n            let goal = new GoalNear(x, y, z);\n            if (dy === 0) {\n                goal = new GoalNearXZ(x, z);\n            }\n            bot.pathfinder.setGoal(goal);\n            try {\n                const result = callback();"
        },
        {
            "comment": "The code performs an exploration task with a maximum time limit. If the exploration succeeds within the specified time, it cleans up and resolves the result. Otherwise, it cleans up, rejects the error, and resolves null. The code sets two intervals: one for exploration at 2-second intervals, and another for timeout after the maximum time in milliseconds.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/control_primitives/exploreUntil.js\":67-86",
            "content": "                if (result) {\n                    cleanUp();\n                    bot.chat(\"Explore success.\");\n                    resolve(result);\n                }\n            } catch (err) {\n                cleanUp();\n                reject(err);\n            }\n        };\n        explorationInterval = setInterval(explore, 2000);\n        maxTimeTimeout = setTimeout(() => {\n            cleanUp();\n            bot.chat(\"Max exploration time reached\");\n            resolve(null);\n        }, maxTime * 1000);\n    });\n}"
        }
    ]
}