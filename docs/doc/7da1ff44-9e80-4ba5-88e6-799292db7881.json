{
    "summary": "This code offers JSON handling functions, correcting escapes and braces count imbalance using aliases. It removes non-JSON content before validating with Python's json.loads().",
    "details": [
        {
            "comment": "The code defines various functions for handling JSON data: `json_load`, `json_loads`, `json_dump`, and `json_dumps`. It also includes aliases for these functions prefixed with \"load_\", \"dump_\", and \"dumps_\". The function `extract_char_position` extracts the character position from a JSONDecodeError error message.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/json_utils.py\":0-43",
            "content": "import json\nimport re\nfrom typing import Any, Dict, Union\nfrom .file_utils import f_join\ndef json_load(*file_path, **kwargs):\n    file_path = f_join(file_path)\n    with open(file_path, \"r\") as fp:\n        return json.load(fp, **kwargs)\ndef json_loads(string, **kwargs):\n    return json.loads(string, **kwargs)\ndef json_dump(data, *file_path, **kwargs):\n    file_path = f_join(file_path)\n    with open(file_path, \"w\") as fp:\n        json.dump(data, fp, **kwargs)\ndef json_dumps(data, **kwargs):\n    \"\"\"\n    Returns: string\n    \"\"\"\n    return json.dumps(data, **kwargs)\n# ---------------- Aliases -----------------\n# add aliases where verb goes first, json_load -> load_json\nload_json = json_load\nloads_json = json_loads\ndump_json = json_dump\ndumps_json = json_dumps\ndef extract_char_position(error_message: str) -> int:\n    \"\"\"Extract the character position from the JSONDecodeError message.\n    Args:\n        error_message (str): The error message from the JSONDecodeError\n          exception.\n    Returns:\n        int: The character position."
        },
        {
            "comment": "Code snippet includes three functions: \n1. `char_position()` - searches for character position in error message using regex and returns the integer value.\n2. `add_quotes_to_property_names()` - adds quotes to property names in JSON string, ensuring valid syntax.\n3. `balance_braces()` - balances braces in a JSON string to ensure proper syntax.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/json_utils.py\":44-82",
            "content": "    \"\"\"\n    import re\n    char_pattern = re.compile(r\"\\(char (\\d+)\\)\")\n    if match := char_pattern.search(error_message):\n        return int(match[1])\n    else:\n        raise ValueError(\"Character position not found in the error message.\")\ndef add_quotes_to_property_names(json_string: str) -> str:\n    \"\"\"\n    Add quotes to property names in a JSON string.\n    Args:\n        json_string (str): The JSON string.\n    Returns:\n        str: The JSON string with quotes added to property names.\n    \"\"\"\n    def replace_func(match):\n        return f'\"{match.group(1)}\":'\n    property_name_pattern = re.compile(r\"(\\w+):\")\n    corrected_json_string = property_name_pattern.sub(replace_func, json_string)\n    try:\n        json.loads(corrected_json_string)\n        return corrected_json_string\n    except json.JSONDecodeError as e:\n        raise e\ndef balance_braces(json_string: str) -> str:\n    \"\"\"\n    Balance the braces in a JSON string.\n    Args:\n        json_string (str): The JSON string.\n    Returns:\n        str: The JSON string with braces balanced."
        },
        {
            "comment": "This code fixes common JSON errors by adding missing closing braces, removing invalid escapes and ensures the corrected string is valid JSON. The function \"fix_invalid_escape\" handles removing invalid escape characters, \"correct_json\" adjusts closing brace count imbalance and \"corrected_json_string\" verifies if the string is a valid JSON.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/json_utils.py\":83-119",
            "content": "    \"\"\"\n    open_braces_count = json_string.count(\"{\")\n    close_braces_count = json_string.count(\"}\")\n    while open_braces_count > close_braces_count:\n        json_string += \"}\"\n        close_braces_count += 1\n    while close_braces_count > open_braces_count:\n        json_string = json_string.rstrip(\"}\")\n        close_braces_count -= 1\n    try:\n        json.loads(json_string)\n        return json_string\n    except json.JSONDecodeError as e:\n        raise e\ndef fix_invalid_escape(json_str: str, error_message: str) -> str:\n    while error_message.startswith(\"Invalid \\\\escape\"):\n        bad_escape_location = extract_char_position(error_message)\n        json_str = json_str[:bad_escape_location] + json_str[bad_escape_location + 1 :]\n        try:\n            json.loads(json_str)\n            return json_str\n        except json.JSONDecodeError as e:\n            error_message = str(e)\n    return json_str\ndef correct_json(json_str: str) -> str:\n    \"\"\"\n    Correct common JSON errors.\n    Args:\n        json_str (str): The JSON string."
        },
        {
            "comment": "This code attempts to fix and parse a potentially invalid JSON string. It first tries to load the string using `json.loads()`. If this fails with a `JSONDecodeError`, it checks the error message for specific issues like escape characters or missing quotes, and applies fixes accordingly before retrying to load the string as JSON. If none of these methods succeed, the original JSON string is returned. The function also includes an optional flag to try to fix the string using GPT (Generic Programming Tool), but this feature seems to be unimplemented in the provided code.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/json_utils.py\":120-151",
            "content": "    \"\"\"\n    try:\n        json.loads(json_str)\n        return json_str\n    except json.JSONDecodeError as e:\n        error_message = str(e)\n        if error_message.startswith(\"Invalid \\\\escape\"):\n            json_str = fix_invalid_escape(json_str, error_message)\n        if error_message.startswith(\n            \"Expecting property name enclosed in double quotes\"\n        ):\n            json_str = add_quotes_to_property_names(json_str)\n            try:\n                json.loads(json_str)\n                return json_str\n            except json.JSONDecodeError as e:\n                error_message = str(e)\n        if balanced_str := balance_braces(json_str):\n            return balanced_str\n    return json_str\ndef fix_and_parse_json(\n    json_str: str, try_to_fix_with_gpt: bool = True\n) -> Union[str, Dict[Any, Any]]:\n    \"\"\"Fix and parse JSON string\"\"\"\n    try:\n        json_str = json_str.replace(\"\\t\", \"\")\n        return json.loads(json_str)\n    except json.JSONDecodeError as _:  # noqa: F841\n        json_str = correct_json(json_str)"
        },
        {
            "comment": "This code attempts to handle JSON strings where the AI response may contain text before the opening brace. It first tries to parse the original string using json.loads(), then, if an error occurs, it finds the first opening brace, removes any non-JSON text before it, and parses the remaining string as JSON.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/json_utils.py\":152-175",
            "content": "        try:\n            return json.loads(json_str)\n        except json.JSONDecodeError as _:  # noqa: F841\n            pass\n    # Let's do something manually:\n    # sometimes GPT responds with something BEFORE the braces:\n    # \"I'm sorry, I don't understand. Please try again.\"\n    # {\"text\": \"I'm sorry, I don't understand. Please try again.\",\n    #  \"confidence\": 0.0}\n    # So let's try to find the first brace and then parse the rest\n    #  of the string\n    try:\n        brace_index = json_str.index(\"{\")\n        json_str = json_str[brace_index:]\n        last_brace_index = json_str.rindex(\"}\")\n        json_str = json_str[: last_brace_index + 1]\n        return json.loads(json_str)\n    except json.JSONDecodeError as e:  # noqa: F841\n        # if try_to_fix_with_gpt:\n        #     print(\n        #         \"Warning: Failed to parse AI output, attempting to fix.\"\n        #         \"\\n If you see this warning frequently, it's likely that\"\n        #         \" your prompt is confusing the AI. Try changing it up\"\n        #         \" slightly.\""
        },
        {
            "comment": "The code attempts to fix a JSON string by using the function `fix_json` with a provided schema. If the AI-fixed JSON is not \"failed\", it will be loaded using `json.loads`. If the fix fails, it prints a message and returns the original JSON string. The function utilizes an AI to correct the JSON string according to the given schema.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/json_utils.py\":176-199",
            "content": "        #     )\n        #     # Now try to fix this up using the ai_functions\n        #     ai_fixed_json = fix_json(json_str, JSON_SCHEMA)\n        #\n        #     if ai_fixed_json != \"failed\":\n        #         return json.loads(ai_fixed_json)\n        #     else:\n        #         # This allows the AI to react to the error message,\n        #         #   which usually results in it correcting its ways.\n        #         print(\"Failed to fix ai output, telling the AI.\")\n        #         return json_str\n        # else:\n        raise e\n# def fix_json(json_str: str, schema: str) -> str:\n#     \"\"\"Fix the given JSON string to make it parseable and fully complient with the provided schema.\"\"\"\n#\n#     # Try to fix the JSON using gpt:\n#     function_string = \"def fix_json(json_str: str, schema:str=None) -> str:\"\n#     args = [f\"'''{json_str}'''\", f\"'''{schema}'''\"]\n#     description_string = (\n#         \"Fixes the provided JSON string to make it parseable\"\n#         \" and fully complient with the provided schema.\\n If an object or\""
        },
        {
            "comment": "This code is attempting to fix incorrect JSON format by enclosing it within triple backticks, and then validating the corrected JSON using Python's json.loads() method. If the JSON remains invalid, an error will be raised. This function is designed to handle cases where the input JSON has minor formatting issues.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/json_utils.py\":200-225",
            "content": "#         \" field specified in the schema isn't contained within the correct\"\n#         \" JSON, it is ommited.\\n This function is brilliant at guessing\"\n#         \" when the format is incorrect.\"\n#     )\n#\n#     # If it doesn't already start with a \"`\", add one:\n#     if not json_str.startswith(\"`\"):\n#         json_str = \"```json\\n\" + json_str + \"\\n```\"\n#     result_string = call_ai_function(\n#         function_string, args, description_string, model=cfg.fast_llm_model\n#     )\n#     if cfg.debug:\n#         print(\"------------ JSON FIX ATTEMPT ---------------\")\n#         print(f\"Original JSON: {json_str}\")\n#         print(\"-----------\")\n#         print(f\"Fixed JSON: {result_string}\")\n#         print(\"----------- END OF FIX ATTEMPT ----------------\")\n#\n#     try:\n#         json.loads(result_string)  # just check the validity\n#         return result_string\n#     except:  # noqa: E722\n#         # Get the call stack:\n#         # import traceback\n#         # call_stack = traceback.format_exc()\n#         # print(f\"Failed to fix JSON: '{json_str}' \"+call_stack)"
        },
        {
            "comment": "This line of code is conditionally returning the string \"failed\" as a result. It's likely part of an if statement or function that evaluates some input and assigns this value based on specific criteria not shown in this snippet.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/json_utils.py\":226-226",
            "content": "#         return \"failed\""
        }
    ]
}