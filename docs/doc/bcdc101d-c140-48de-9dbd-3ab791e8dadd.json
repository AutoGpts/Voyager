{
    "summary": "The `VoyagerEnv` class sets up a Minecraft server using Mineflayer, providing pause/unpause functionality and returning the mineflayer instance with Azure login. It also has methods to reset and render, and classes for stopping, closing, and rendering the server.",
    "details": [
        {
            "comment": "This code defines a class `VoyagerEnv` that inherits from `gym.Env`, which represents an environment in the gymnasium framework. The constructor takes parameters such as `mc_port`, `azure_login`, `server_host`, `server_port`, `request_timeout`, and `log_path`. If neither `mc_port` nor `azure_login` is specified, a ValueError will be raised. If both are specified, a warning is logged and `mc_port` is ignored. The class likely interacts with Minecraft instances using the `MinecraftInstance` and `SubprocessMonitor` classes.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/env/bridge.py\":0-37",
            "content": "import os.path\nimport time\nimport warnings\nfrom typing import SupportsFloat, Any, Tuple, Dict\nimport requests\nimport json\nimport gymnasium as gym\nfrom gymnasium.core import ObsType\nimport voyager.utils as U\nfrom .minecraft_launcher import MinecraftInstance\nfrom .process_monitor import SubprocessMonitor\nclass VoyagerEnv(gym.Env):\n    def __init__(\n        self,\n        mc_port=None,\n        azure_login=None,\n        server_host=\"http://127.0.0.1\",\n        server_port=3000,\n        request_timeout=600,\n        log_path=\"./logs\",\n    ):\n        if not mc_port and not azure_login:\n            raise ValueError(\"Either mc_port or azure_login must be specified\")\n        if mc_port and azure_login:\n            warnings.warn(\n                \"Both mc_port and mc_login are specified, mc_port will be ignored\"\n            )\n        self.mc_port = mc_port\n        self.azure_login = azure_login\n        self.server = f\"{server_host}:{server_port}\"\n        self.server_port = server_port\n        self.request_timeout = request_timeout"
        },
        {
            "comment": "This code sets up a Minecraft server using Mineflayer and MinecraftInstance. It initializes the necessary variables, gets the mineflayer process running with specified server port, creates directories for logs, and returns the mineflayer instance if Azure login is provided, or None otherwise.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/env/bridge.py\":38-67",
            "content": "        self.log_path = log_path\n        self.mineflayer = self.get_mineflayer_process(server_port)\n        if azure_login:\n            self.mc_instance = self.get_mc_instance()\n        else:\n            self.mc_instance = None\n        self.has_reset = False\n        self.reset_options = None\n        self.connected = False\n        self.server_paused = False\n    def get_mineflayer_process(self, server_port):\n        U.f_mkdir(self.log_path, \"mineflayer\")\n        file_path = os.path.abspath(os.path.dirname(__file__))\n        return SubprocessMonitor(\n            commands=[\n                \"node\",\n                U.f_join(file_path, \"mineflayer/index.js\"),\n                str(server_port),\n            ],\n            name=\"mineflayer\",\n            ready_match=r\"Server started on port (\\d+)\",\n            log_path=U.f_join(self.log_path, \"mineflayer\"),\n        )\n    def get_mc_instance(self):\n        print(\"Creating Minecraft server\")\n        U.f_mkdir(self.log_path, \"minecraft\")\n        return MinecraftInstance(\n            **self.azure_login,"
        },
        {
            "comment": "The code checks if the Minecraft server and Mineflayer processes are running. If not, it starts the Minecraft server and restarts the Mineflayer process if it exits. It also makes a POST request.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/env/bridge.py\":68-92",
            "content": "            mineflayer=self.mineflayer,\n            log_path=U.f_join(self.log_path, \"minecraft\"),\n        )\n    def check_process(self):\n        if self.mc_instance and not self.mc_instance.is_running:\n            # if self.mc_instance:\n            #     self.mc_instance.check_process()\n            #     if not self.mc_instance.is_running:\n            print(\"Starting Minecraft server\")\n            self.mc_instance.run()\n            self.mc_port = self.mc_instance.port\n            self.reset_options[\"port\"] = self.mc_instance.port\n            print(f\"Server started on port {self.reset_options['port']}\")\n        retry = 0\n        while not self.mineflayer.is_running:\n            print(\"Mineflayer process has exited, restarting\")\n            self.mineflayer.run()\n            if not self.mineflayer.is_running:\n                if retry > 3:\n                    raise RuntimeError(\"Mineflayer process failed to start\")\n                else:\n                    continue\n            print(self.mineflayer.ready_line)\n            res = requests.post("
        },
        {
            "comment": "This code defines a class with methods for resetting the environment, stepping the Minecraft server, and returning observed data. It uses requests library to send HTTP POST requests to the server's \"start\" and \"step\" endpoints, checking status codes and handling errors accordingly. The class also has methods for pausing and unpausing the Minecraft server execution.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/env/bridge.py\":93-124",
            "content": "                f\"{self.server}/start\",\n                json=self.reset_options,\n                timeout=self.request_timeout,\n            )\n            if res.status_code != 200:\n                self.mineflayer.stop()\n                raise RuntimeError(\n                    f\"Minecraft server reply with code {res.status_code}\"\n                )\n            return res.json()\n    def step(\n        self,\n        code: str,\n        programs: str = \"\",\n    ) -> Tuple[ObsType, SupportsFloat, bool, bool, Dict[str, Any]]:\n        if not self.has_reset:\n            raise RuntimeError(\"Environment has not been reset yet\")\n        self.check_process()\n        self.unpause()\n        data = {\n            \"code\": code,\n            \"programs\": programs,\n        }\n        res = requests.post(\n            f\"{self.server}/step\", json=data, timeout=self.request_timeout\n        )\n        if res.status_code != 200:\n            raise RuntimeError(\"Failed to step Minecraft server\")\n        returned_data = res.json()\n        self.pause()\n        return json.loads(returned_data)"
        },
        {
            "comment": "The code defines two methods, \"render\" and \"reset\". The \"render\" method raises a \"NotImplementedError\", indicating it's not implemented. The \"reset\" method takes optional seed and options parameters, sets reset options (port, mode, inventory, equipment, spread, waitTicks, position), stops the mineflayer, waits for it to exit, checks process status, and marks has_reset as True.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/env/bridge.py\":126-157",
            "content": "    def render(self):\n        raise NotImplementedError(\"render is not implemented\")\n    def reset(\n        self,\n        *,\n        seed=None,\n        options=None,\n    ) -> Tuple[ObsType, Dict[str, Any]]:\n        if options is None:\n            options = {}\n        if options.get(\"inventory\", {}) and options.get(\"mode\", \"hard\") != \"hard\":\n            raise RuntimeError(\"inventory can only be set when options is hard\")\n        self.reset_options = {\n            \"port\": self.mc_port,\n            \"reset\": options.get(\"mode\", \"hard\"),\n            \"inventory\": options.get(\"inventory\", {}),\n            \"equipment\": options.get(\"equipment\", []),\n            \"spread\": options.get(\"spread\", False),\n            \"waitTicks\": options.get(\"wait_ticks\", 5),\n            \"position\": options.get(\"position\", None),\n        }\n        self.unpause()\n        self.mineflayer.stop()\n        time.sleep(1)  # wait for mineflayer to exit\n        returned_data = self.check_process()\n        self.has_reset = True\n        self.connected = True"
        },
        {
            "comment": "This code defines a class with methods to pause and unpause the server, stop the minecraft instance, and close the connection. The reset_options are set to \"soft\" and it returns parsed JSON data from an API request.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/env/bridge.py\":158-188",
            "content": "        # All the reset in step will be soft\n        self.reset_options[\"reset\"] = \"soft\"\n        self.pause()\n        return json.loads(returned_data)\n    def close(self):\n        self.unpause()\n        if self.connected:\n            res = requests.post(f\"{self.server}/stop\")\n            if res.status_code == 200:\n                self.connected = False\n        if self.mc_instance:\n            self.mc_instance.stop()\n        self.mineflayer.stop()\n        return not self.connected\n    def pause(self):\n        if self.mineflayer.is_running and not self.server_paused:\n            res = requests.post(f\"{self.server}/pause\")\n            if res.status_code == 200:\n                self.server_paused = True\n        return self.server_paused\n    def unpause(self):\n        if self.mineflayer.is_running and self.server_paused:\n            res = requests.post(f\"{self.server}/pause\")\n            if res.status_code == 200:\n                self.server_paused = False\n            else:\n                print(res.json())\n        return self.server_paused"
        }
    ]
}