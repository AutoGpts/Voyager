{
    "summary": "The ActionAgent class handles agent behavior, using ChatOpenAI for language processing and offering options like chat log and error handling. It defines methods to update chest memory, render observations, and send actions, while processing game events, constructing observation strings, handling inventory, checking chest involvement, and executing async functions with error handling and item filtering.",
    "details": [
        {
            "comment": "Initializing the ActionAgent class by setting its attributes and loading the necessary files. This class is used to control agent behavior, utilizing the ChatOpenAI language model for generating responses. It also has options for chat log, execution error handling, and saving/loading checkpoints for state persistence.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/action.py\":0-33",
            "content": "import re\nimport time\nimport voyager.utils as U\nfrom javascript import require\nfrom langchain.chat_models import ChatOpenAI\nfrom langchain.prompts import SystemMessagePromptTemplate\nfrom langchain.schema import AIMessage, HumanMessage, SystemMessage\nfrom voyager.prompts import load_prompt\nfrom voyager.control_primitives_context import load_control_primitives_context\nclass ActionAgent:\n    def __init__(\n        self,\n        model_name=\"gpt-3.5-turbo\",\n        temperature=0,\n        request_timout=120,\n        ckpt_dir=\"ckpt\",\n        resume=False,\n        chat_log=True,\n        execution_error=True,\n    ):\n        self.ckpt_dir = ckpt_dir\n        self.chat_log = chat_log\n        self.execution_error = execution_error\n        U.f_mkdir(f\"{ckpt_dir}/action\")\n        if resume:\n            print(f\"\\033[32mLoading Action Agent from {ckpt_dir}/action\\033[0m\")\n            self.chest_memory = U.load_json(f\"{ckpt_dir}/action/chest_memory.json\")\n        else:\n            self.chest_memory = {}\n        self.llm = ChatOpenAI("
        },
        {
            "comment": "The code defines a class with methods for updating the agent's chest memory, rendering chest observations, and sending actions. It initializes an action agent using a model_name, temperature, and request_timeout. The update_chest_memory method checks if the chest already exists in the chest_memory dictionary and updates or removes it accordingly. If not present, it saves the new chest. Finally, the render_chest_observation method creates a list of chests from the chest memory and returns it.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/action.py\":34-58",
            "content": "            model_name=model_name,\n            temperature=temperature,\n            request_timeout=request_timout,\n        )\n    def update_chest_memory(self, chests):\n        for position, chest in chests.items():\n            if position in self.chest_memory:\n                if isinstance(chest, dict):\n                    self.chest_memory[position] = chest\n                if chest == \"Invalid\":\n                    print(\n                        f\"\\033[32mAction Agent removing chest {position}: {chest}\\033[0m\"\n                    )\n                    self.chest_memory.pop(position)\n            else:\n                if chest != \"Invalid\":\n                    print(f\"\\033[32mAction Agent saving chest {position}: {chest}\\033[0m\")\n                    self.chest_memory[position] = chest\n        U.dump_json(self.chest_memory, f\"{self.ckpt_dir}/action/chest_memory.json\")\n    def render_chest_observation(self):\n        chests = []\n        for chest_position, chest in self.chest_memory.items():\n            if isinstance(chest, dict) and len(chest) > 0:"
        },
        {
            "comment": "This code snippet is a part of the 'action.py' file in the Voyager project. It seems to be responsible for fetching information about chests from a data structure called 'chest_memory'. If a chest is empty, its status is updated accordingly. The function also checks if there are any unknown items inside a chest and updates its status as well. Finally, it returns the information on all chests found in the format of \"Chests: <list of chests>\". If no chests are found, it returns \"Chests: None\". Additionally, there's a comment indicating that this code may not work with a specific model_name (gpt-3.5-turbo).",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/action.py\":59-85",
            "content": "                chests.append(f\"{chest_position}: {chest}\")\n        for chest_position, chest in self.chest_memory.items():\n            if isinstance(chest, dict) and len(chest) == 0:\n                chests.append(f\"{chest_position}: Empty\")\n        for chest_position, chest in self.chest_memory.items():\n            if isinstance(chest, str):\n                assert chest == \"Unknown\"\n                chests.append(f\"{chest_position}: Unknown items inside\")\n        assert len(chests) == len(self.chest_memory)\n        if chests:\n            chests = \"\\n\".join(chests)\n            return f\"Chests:\\n{chests}\\n\\n\"\n        else:\n            return f\"Chests: None\\n\\n\"\n    def render_system_message(self, skills=[]):\n        system_template = load_prompt(\"action_template\")\n        # FIXME: Hardcoded control_primitives\n        base_skills = [\n            \"exploreUntil\",\n            \"mineBlock\",\n            \"craftItem\",\n            \"placeItem\",\n            \"smeltItem\",\n            \"killMob\",\n        ]\n        if not self.llm.model_name == \"gpt-3.5-turbo\":"
        },
        {
            "comment": "The code initializes system message components by joining base skills with additional skills, loading the response format template, creating a system message prompt, and formatting the system message with the joined programs and response format. The render_human_message function creates chat messages, error messages, and damage messages based on event types. It asserts that the last event is \"observe\".",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/action.py\":86-111",
            "content": "            base_skills += [\n                \"useChest\",\n                \"mineflayer\",\n            ]\n        programs = \"\\n\\n\".join(load_control_primitives_context(base_skills) + skills)\n        response_format = load_prompt(\"action_response_format\")\n        system_message_prompt = SystemMessagePromptTemplate.from_template(\n            system_template\n        )\n        system_message = system_message_prompt.format(\n            programs=programs, response_format=response_format\n        )\n        assert isinstance(system_message, SystemMessage)\n        return system_message\n    def render_human_message(\n        self, *, events, code=\"\", task=\"\", context=\"\", critique=\"\"\n    ):\n        chat_messages = []\n        error_messages = []\n        # FIXME: damage_messages is not used\n        damage_messages = []\n        assert events[-1][0] == \"observe\", \"Last event must be observe\"\n        for i, (event_type, event) in enumerate(events):\n            if event_type == \"onChat\":\n                chat_messages.append(event[\"onChat\"])"
        },
        {
            "comment": "This code handles different event types in a game agent. It appends error and damage messages, collects observe data like biome, time of day, voxels, entities, health, hunger, position, equipment, inventory used, and the inventory itself. Then it constructs an observation string based on if there's code from the last round or not.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/action.py\":112-134",
            "content": "            elif event_type == \"onError\":\n                error_messages.append(event[\"onError\"])\n            elif event_type == \"onDamage\":\n                damage_messages.append(event[\"onDamage\"])\n            elif event_type == \"observe\":\n                biome = event[\"status\"][\"biome\"]\n                time_of_day = event[\"status\"][\"timeOfDay\"]\n                voxels = event[\"voxels\"]\n                entities = event[\"status\"][\"entities\"]\n                health = event[\"status\"][\"health\"]\n                hunger = event[\"status\"][\"food\"]\n                position = event[\"status\"][\"position\"]\n                equipment = event[\"status\"][\"equipment\"]\n                inventory_used = event[\"status\"][\"inventoryUsed\"]\n                inventory = event[\"inventory\"]\n                assert i == len(events) - 1, \"observe must be the last event\"\n        observation = \"\"\n        if code:\n            observation += f\"Code from the last round:\\n{code}\\n\\n\"\n        else:\n            observation += f\"Code from the last round: No code in the first round\\n\\n\""
        },
        {
            "comment": "This code snippet is part of a larger program that appears to be an AI agent. It generates an observation for the agent, including information about execution errors, chat logs, biome, time of day, nearby blocks and entities. The observation is constructed by iterating through various lists, joining them with newlines, and appending them to the \"observation\" string variable. If a list is empty, a corresponding message is added to the observation.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/action.py\":136-165",
            "content": "        if self.execution_error:\n            if error_messages:\n                error = \"\\n\".join(error_messages)\n                observation += f\"Execution error:\\n{error}\\n\\n\"\n            else:\n                observation += f\"Execution error: No error\\n\\n\"\n        if self.chat_log:\n            if chat_messages:\n                chat_log = \"\\n\".join(chat_messages)\n                observation += f\"Chat log: {chat_log}\\n\\n\"\n            else:\n                observation += f\"Chat log: None\\n\\n\"\n        observation += f\"Biome: {biome}\\n\\n\"\n        observation += f\"Time: {time_of_day}\\n\\n\"\n        if voxels:\n            observation += f\"Nearby blocks: {', '.join(voxels)}\\n\\n\"\n        else:\n            observation += f\"Nearby blocks: None\\n\\n\"\n        if entities:\n            nearby_entities = [\n                k for k, v in sorted(entities.items(), key=lambda x: x[1])\n            ]\n            observation += f\"Nearby entities (nearest to farthest): {', '.join(nearby_entities)}\\n\\n\"\n        else:\n            observation += f\"Nearby entities (nearest to farthest): None\\n\\n\""
        },
        {
            "comment": "This code generates an observation string containing the agent's health, hunger, position, equipment, inventory, and task. It also checks if a chest is involved in the current task, adds chest information if necessary, and includes context and critique if available. The final result is returned as a HumanMessage object.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/action.py\":167-198",
            "content": "        observation += f\"Health: {health:.1f}/20\\n\\n\"\n        observation += f\"Hunger: {hunger:.1f}/20\\n\\n\"\n        observation += f\"Position: x={position['x']:.1f}, y={position['y']:.1f}, z={position['z']:.1f}\\n\\n\"\n        observation += f\"Equipment: {equipment}\\n\\n\"\n        if inventory:\n            observation += f\"Inventory ({inventory_used}/36): {inventory}\\n\\n\"\n        else:\n            observation += f\"Inventory ({inventory_used}/36): Empty\\n\\n\"\n        if not (\n            task == \"Place and deposit useless items into a chest\"\n            or task.startswith(\"Deposit useless items into the chest at\")\n        ):\n            observation += self.render_chest_observation()\n        observation += f\"Task: {task}\\n\\n\"\n        if context:\n            observation += f\"Context: {context}\\n\\n\"\n        else:\n            observation += f\"Context: None\\n\\n\"\n        if critique:\n            observation += f\"Critique: {critique}\\n\\n\"\n        else:\n            observation += f\"Critique: None\\n\\n\"\n        return HumanMessage(content=observation)"
        },
        {
            "comment": "The code defines a function process_ai_message, which takes an AIMessage object as input. It checks if the message is of correct type, then enters a while loop to handle potential errors. Inside the loop, it imports required libraries and compiles the JavaScript/JS code from the message content using Babel. It parses the compiled code and extracts function declarations from the program's body. If no functions are found, it raises an assertion error. The extracted functions are then stored in a list. This function seems to be part of an AI agent for processing messages containing JavaScript/JS code snippets.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/action.py\":200-225",
            "content": "    def process_ai_message(self, message):\n        assert isinstance(message, AIMessage)\n        retry = 3\n        error = None\n        while retry > 0:\n            try:\n                babel = require(\"@babel/core\")\n                babel_generator = require(\"@babel/generator\").default\n                code_pattern = re.compile(r\"```(?:javascript|js)(.*?)```\", re.DOTALL)\n                code = \"\\n\".join(code_pattern.findall(message.content))\n                parsed = babel.parse(code)\n                functions = []\n                assert len(list(parsed.program.body)) > 0, \"No functions found\"\n                for i, node in enumerate(parsed.program.body):\n                    if node.type != \"FunctionDeclaration\":\n                        continue\n                    node_type = (\n                        \"AsyncFunctionDeclaration\"\n                        if node[\"async\"]\n                        else \"FunctionDeclaration\"\n                    )\n                    functions.append(\n                        {\n                            \"name\": node.id.name,"
        },
        {
            "comment": "This code finds the last async function in a list of functions, asserts that there is one and it takes a single argument named \"bot\", then joins the bodies of all functions into program_code. It then creates an executable line of code with the main_function name and awaits its execution.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/action.py\":226-245",
            "content": "                            \"type\": node_type,\n                            \"body\": babel_generator(node).code,\n                            \"params\": list(node[\"params\"]),\n                        }\n                    )\n                # find the last async function\n                main_function = None\n                for function in reversed(functions):\n                    if function[\"type\"] == \"AsyncFunctionDeclaration\":\n                        main_function = function\n                        break\n                assert (\n                    main_function is not None\n                ), \"No async function found. Your main function must be async.\"\n                assert (\n                    len(main_function[\"params\"]) == 1\n                    and main_function[\"params\"][0].name == \"bot\"\n                ), f\"Main function {main_function['name']} must take a single argument named 'bot'\"\n                program_code = \"\\n\\n\".join(function[\"body\"] for function in functions)\n                exec_code = f\"await {main_function['name']}(bot);\""
        },
        {
            "comment": "The code defines a function that parses action responses and filters chat log messages for specific item requirements before program execution. It also includes error handling and retry mechanisms in case of exceptions during parsing. The chat log filtering uses regular expressions to match patterns and extract the required items.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/action.py\":246-269",
            "content": "                return {\n                    \"program_code\": program_code,\n                    \"program_name\": main_function[\"name\"],\n                    \"exec_code\": exec_code,\n                }\n            except Exception as e:\n                retry -= 1\n                error = e\n                time.sleep(1)\n        return f\"Error parsing action response (before program execution): {error}\"\n    def summarize_chatlog(self, events):\n        def filter_item(message: str):\n            craft_pattern = r\"I cannot make \\w+ because I need: (.*)\"\n            craft_pattern2 = (\n                r\"I cannot make \\w+ because there is no crafting table nearby\"\n            )\n            mine_pattern = r\"I need at least a (.*) to mine \\w+!\"\n            if re.match(craft_pattern, message):\n                return re.match(craft_pattern, message).groups()[0]\n            elif re.match(craft_pattern2, message):\n                return \"a nearby crafting table\"\n            elif re.match(mine_pattern, message):\n                return re.match(mine_pattern, message).groups()[0]"
        },
        {
            "comment": "Code checks for events of type \"onChat\", filters the items, and adds them to chatlog. If chatlog is not empty, returns a message mentioning required items. Otherwise, returns an empty string.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/agents/action.py\":270-279",
            "content": "            else:\n                return \"\"\n        chatlog = set()\n        for event_type, event in events:\n            if event_type == \"onChat\":\n                item = filter_item(event[\"onChat\"])\n                if item:\n                    chatlog.add(item)\n        return \"I also need \" + \", \".join(chatlog) + \".\" if chatlog else \"\""
        }
    ]
}