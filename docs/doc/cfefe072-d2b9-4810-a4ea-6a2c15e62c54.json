{
    "summary": "The EventRecorder class records events, updates elapsed time and item history, and maintains dictionaries for item-time associations and iteration items. It has a resume method and sorts records based on timestamps.",
    "details": [
        {
            "comment": "Class EventRecorder initializes attributes, sets up a directory for event files, and handles resuming or starting fresh. It records events for tasks, storing information about each event type in various dictionaries for later use.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/record_utils.py\":0-37",
            "content": "import time\nfrom .file_utils import *\nfrom .json_utils import *\nclass EventRecorder:\n    def __init__(\n        self,\n        ckpt_dir=\"ckpt\",\n        resume=False,\n        init_position=None,\n    ):\n        self.ckpt_dir = ckpt_dir\n        self.item_history = set()\n        self.item_vs_time = {}\n        self.item_vs_iter = {}\n        self.biome_history = set()\n        self.init_position = init_position\n        self.position_history = [[0, 0]]\n        self.elapsed_time = 0\n        self.iteration = 0\n        f_mkdir(self.ckpt_dir, \"events\")\n        if resume:\n            self.resume()\n    def record(self, events, task):\n        task = re.sub(r'[\\\\/:\"*?<>| ]', \"_\", task)\n        task = task.replace(\" \", \"_\") + time.strftime(\n            \"_%Y%m%d_%H%M%S\", time.localtime()\n        )\n        self.iteration += 1\n        if not self.init_position:\n            self.init_position = [\n                events[0][1][\"status\"][\"position\"][\"x\"],\n                events[0][1][\"status\"][\"position\"][\"z\"],\n            ]\n        for event_type, event in events:"
        },
        {
            "comment": "The code is part of a Recorder class responsible for recording events. It updates elapsed time and iteration, prints messages, dumps JSON data to disk, and provides a resume method to continue from a specific cutoff point. The get_timestamp function helps sort the records based on timestamps.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/record_utils.py\":38-63",
            "content": "            self.update_items(event)\n            if event_type == \"observe\":\n                self.update_elapsed_time(event)\n        print(\n            f\"\\033[96m****Recorder message: {self.elapsed_time} ticks have elapsed****\\033[0m\\n\"\n            f\"\\033[96m****Recorder message: {self.iteration} iteration passed****\\033[0m\"\n        )\n        dump_json(events, f_join(self.ckpt_dir, \"events\", task))\n    def resume(self, cutoff=None):\n        self.item_history = set()\n        self.item_vs_time = {}\n        self.item_vs_iter = {}\n        self.elapsed_time = 0\n        self.position_history = [[0, 0]]\n        def get_timestamp(string):\n            timestamp = \"_\".join(string.split(\"_\")[-2:])\n            return time.mktime(time.strptime(timestamp, \"%Y%m%d_%H%M%S\"))\n        records = f_listdir(self.ckpt_dir, \"events\")\n        sorted_records = sorted(records, key=get_timestamp)\n        for record in sorted_records:\n            self.iteration += 1\n            if cutoff and self.iteration > cutoff:\n                break"
        },
        {
            "comment": "This code loads event data and updates the position, items, and elapsed time based on each event type. It also maintains a history of items and biomes encountered over time. New items are added to the item_vs_time dictionary, which tracks when they were first encountered.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/record_utils.py\":64-87",
            "content": "            events = load_json(f_join(self.ckpt_dir, \"events\", record))\n            if not self.init_position:\n                self.init_position = (\n                    events[0][1][\"status\"][\"position\"][\"x\"],\n                    events[0][1][\"status\"][\"position\"][\"z\"],\n                )\n            for event_type, event in events:\n                self.update_items(event)\n                self.update_position(event)\n                if event_type == \"observe\":\n                    self.update_elapsed_time(event)\n    def update_items(self, event):\n        inventory = event[\"inventory\"]\n        elapsed_time = event[\"status\"][\"elapsedTime\"]\n        biome = event[\"status\"][\"biome\"]\n        items = set(inventory.keys())\n        new_items = items - self.item_history\n        self.item_history.update(items)\n        self.biome_history.add(biome)\n        if new_items:\n            if self.elapsed_time + elapsed_time not in self.item_vs_time:\n                self.item_vs_time[self.elapsed_time + elapsed_time] = []\n            self.item_vs_time[self.elapsed_time + elapsed_time].extend(new_items)"
        },
        {
            "comment": "The `update_position` function checks if the position has changed and adds it to the `position_history` list. The `update_elapsed_time` function increments the elapsed time with the event's elapsed time. The `item_vs_iter` dictionary stores the items associated with each iteration, and if a new iteration is encountered, it initializes an empty list for that iteration in the dictionary.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/utils/record_utils.py\":88-101",
            "content": "            if self.iteration not in self.item_vs_iter:\n                self.item_vs_iter[self.iteration] = []\n            self.item_vs_iter[self.iteration].extend(new_items)\n    def update_elapsed_time(self, event):\n        self.elapsed_time += event[\"status\"][\"elapsedTime\"]\n    def update_position(self, event):\n        position = [\n            event[\"status\"][\"position\"][\"x\"] - self.init_position[0],\n            event[\"status\"][\"position\"][\"z\"] - self.init_position[1],\n        ]\n        if self.position_history[-1] != position:\n            self.position_history.append(position)"
        }
    ]
}