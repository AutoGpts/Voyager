{
    "summary": "This code manages a subprocess, defining a class with methods to control its lifecycle and using threading for concurrency. It initializes subprocesses with commands, sets up event handlers for readiness and completion, and monitors output for specific patterns to call callback functions.",
    "details": [
        {
            "comment": "Class for monitoring subprocesses, taking a list of commands, name, regex patterns for ready and callback conditions, log path, and optional callbacks on process completion. Sets up a logger with time-stamped file handler and initializes process variable.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/env/process_monitor.py\":0-37",
            "content": "import time\nimport re\nimport warnings\nfrom typing import List\nimport psutil\nimport subprocess\nimport logging\nimport threading\nimport voyager.utils as U\nclass SubprocessMonitor:\n    def __init__(\n        self,\n        commands: List[str],\n        name: str,\n        ready_match: str = r\".*\",\n        log_path: str = \"logs\",\n        callback_match: str = r\"^(?!x)x$\",  # regex that will never match\n        callback: callable = None,\n        finished_callback: callable = None,\n    ):\n        self.commands = commands\n        start_time = time.strftime(\"%Y%m%d_%H%M%S\")\n        self.name = name\n        self.logger = logging.getLogger(name)\n        handler = logging.FileHandler(U.f_join(log_path, f\"{start_time}.log\"))\n        formatter = logging.Formatter(\n            \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n        )\n        handler.setFormatter(formatter)\n        self.logger.addHandler(handler)\n        self.logger.setLevel(logging.INFO)\n        self.process = None\n        self.ready_match = ready_match\n        self.ready_event = None"
        },
        {
            "comment": "This code initializes a subprocess with commands and sets up event handlers for its readiness and completion. It monitors the output of the subprocess, looking for specific patterns in each line to determine when it's ready and to call the callback function. If the process fails to start, it raises a warning.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/env/process_monitor.py\":38-64",
            "content": "        self.ready_line = None\n        self.callback_match = callback_match\n        self.callback = callback\n        self.finished_callback = finished_callback\n        self.thread = None\n    def _start(self):\n        self.logger.info(f\"Starting subprocess with commands: {self.commands}\")\n        self.process = psutil.Popen(\n            self.commands,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            universal_newlines=True,\n        )\n        print(f\"Subprocess {self.name} started with PID {self.process.pid}.\")\n        for line in iter(self.process.stdout.readline, \"\"):\n            self.logger.info(line.strip())\n            if re.search(self.ready_match, line):\n                self.ready_line = line\n                self.logger.info(\"Subprocess is ready.\")\n                self.ready_event.set()\n            if re.search(self.callback_match, line):\n                self.callback()\n        if not self.ready_event.is_set():\n            self.ready_event.set()\n            warnings.warn(f\"Subprocess {self.name} failed to start.\")"
        },
        {
            "comment": "This code defines a class that manages a subprocess and provides methods to control its lifecycle, including starting, stopping, and checking if it's still running. It uses the threading module for concurrency and a property to determine if the process is running.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/env/process_monitor.py\":65-89",
            "content": "        if self.finished_callback:\n            self.finished_callback()\n    def run(self):\n        self.ready_event = threading.Event()\n        self.ready_line = None\n        self.thread = threading.Thread(target=self._start)\n        self.thread.start()\n        self.ready_event.wait()\n    def stop(self):\n        self.logger.info(\"Stopping subprocess.\")\n        if self.process and self.process.is_running():\n            self.process.terminate()\n            self.process.wait()\n    # def __del__(self):\n    #     if self.process.is_running():\n    #         self.stop()\n    @property\n    def is_running(self):\n        if self.process is None:\n            return False\n        return self.process.is_running()"
        }
    ]
}