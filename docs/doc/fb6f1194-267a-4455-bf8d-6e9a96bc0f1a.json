{
    "summary": "The code creates a MinecraftInstance class, initializes functions for Mineflayer process and log path, runs node command with script path and server port, handles user login and config options management.",
    "details": [
        {
            "comment": "The code defines a class \"MinecraftInstance\" with attributes such as client_id, redirect_url, secret_value, version, mineflayer, log_path, and mc_dir. It initializes a stop_mineflayer() function to stop the mineflayer process, gets the mc_command using get_mc_command(), and creates a SubprocessMonitor for the minecraft process with specified commands, name, ready_match, and log_path.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/env/minecraft_launcher.py\":0-40",
            "content": "import os\nimport re\nimport minecraft_launcher_lib\nimport sys\nimport voyager.utils as U\nfrom .process_monitor import SubprocessMonitor\nclass MinecraftInstance:\n    def __init__(\n        self,\n        client_id,\n        redirect_url,\n        secret_value,\n        version,\n        mineflayer,\n        log_path=\"logs\",\n    ):\n        self.client_id = client_id\n        self.redirect_url = redirect_url\n        self.secret_value = secret_value\n        self.version = version\n        self.log_path = log_path\n        self.mc_dir = minecraft_launcher_lib.utils.get_minecraft_directory()\n        self.port = None\n        def stop_mineflayer():\n            print(\"Stopping mineflayer\")\n            try:\n                mineflayer.stop()\n            except Exception as e:\n                print(e)\n        self.mc_command = self.get_mc_command()\n        self.mc_process = SubprocessMonitor(\n            commands=self.mc_command,\n            name=\"minecraft\",\n            ready_match=r\"Started serving on (\\d+)\",\n            log_path=self.log_path,"
        },
        {
            "comment": "Line 41-68:\n- Initializes a `SubprocessMonitor` for Mineflayer process\n- Sets the log path to \"../mineflayer\" and gets the absolute file path\n- Runs \"node\" command with the script path, server port as arguments\n- Defines ready match pattern as \"Server started on port (\\d+)\"\n- Checks if config.json exists",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/env/minecraft_launcher.py\":41-68",
            "content": "            callback=stop_mineflayer,\n            callback_match=r\"\\[Server thread/INFO\\]: bot left the game\",\n            finished_callback=stop_mineflayer,\n        )\n    def get_mineflayer_process(self, server_port):\n        U.f_mkdir(self.log_path, \"../mineflayer\")\n        file_path = os.path.abspath(os.path.dirname(__file__))\n        return SubprocessMonitor(\n            commands=[\n                \"node\",\n                U.f_join(file_path, \"mineflayer/index.js\"),\n                str(server_port),\n            ],\n            name=\"mineflayer\",\n            ready_match=r\"Server started on port (\\d+)\",\n            log_path=U.f_join(self.log_path, \"mineflayer\"),\n        )\n    def get_mc_command(self):\n        file_path = os.path.abspath(os.path.dirname(__file__))\n        if not U.f_exists(file_path, \"config.json\"):\n            (\n                login_url,\n                state,\n                code_verifier,\n            ) = minecraft_launcher_lib.microsoft_account.get_secure_login_data(\n                self.client_id, self.redirect_url"
        },
        {
            "comment": "The code prompts the user to open a login URL in their browser, enter the redirected URL into the prompt, and then parses the authentication code from the entered URL. It validates the state and URL, then completes the login process by retrieving the username, UUID, and access token from the login data.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/env/minecraft_launcher.py\":69-99",
            "content": "            )\n            print(\n                f\"Please open {login_url} in your browser and copy the url you are redirected into the prompt below.\"\n            )\n            code_url = input()\n            try:\n                auth_code = (\n                    minecraft_launcher_lib.microsoft_account.parse_auth_code_url(\n                        code_url, state\n                    )\n                )\n            except AssertionError:\n                print(\"States do not match!\")\n                sys.exit(1)\n            except KeyError:\n                print(\"Url not valid\")\n                sys.exit(1)\n            login_data = minecraft_launcher_lib.microsoft_account.complete_login(\n                self.client_id,\n                self.secret_value,\n                self.redirect_url,\n                auth_code,\n                code_verifier,\n            )\n            options = {\n                \"username\": login_data[\"name\"],\n                \"uuid\": login_data[\"id\"],\n                \"token\": login_data[\"access_token\"],"
        },
        {
            "comment": "This code defines a class with methods to start, stop, and check the status of a Minecraft server. It loads or saves configuration options, retrieves the Minecraft command, and prints the port when the server is running.",
            "location": "\"/media/root/Prima/works/Voyager/docs/src/voyager/env/minecraft_launcher.py\":100-126",
            "content": "            }\n            U.json_dump(options, file_path, \"config.json\")\n            print(f\"Login success, save to {U.f_join(file_path, 'config.json')}\")\n        options = U.json_load(file_path, \"config.json\")\n        mc_command = minecraft_launcher_lib.command.get_minecraft_command(\n            self.version, self.mc_dir, options\n        )\n        return mc_command\n    def run(self):\n        self.mc_process.run()\n        pattern = r\"Started serving on (\\d+)\"\n        match = re.search(pattern, self.mc_process.ready_line)\n        if match:\n            self.port = int(match.group(1))\n            print(\"The mc server is listening on port\", self.port)\n        else:\n            raise RuntimeError(\"Port not found\")\n    def stop(self):\n        self.mc_process.stop()\n    @property\n    def is_running(self):\n        return self.mc_process.is_running"
        }
    ]
}